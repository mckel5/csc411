One programming technique I have made an effort to incorporate into my work this semester is using functional programming to reduce boilerplate code. I, like many CS undergrads at URI, have spent the majority of my programming career using object-oriented languages like C++, Java, and Python. These languages absolutely have their merits -- there's a reason why they're so ubiquitous, after all -- but, by design, they introduce a great deal of overhead into programs built with them. For the types of applications Rust excels at, performance and resource management are crucial. Functional programming can help reduce this overhead by simplifying trivial yet repetitive tasks.

Many staples of the functional paradigm, like the "fold" and "map" procedures, eliminate the need for explicit iteration and temporary variables. The focus on pure functionality, moreover, allows programmers to dodge the headaches caused by state management in OOP programs. Rust's relatively bare-bones support for OOP allows functional programming to shine, letting programmers spend less time writing boilerplate code and more time solving problems that actually matter. Functional programming isn't perfect, and I certainly don't think it will steal the crown from OOP any time soon. However, its prominence in the modern software development ethos is undeniable. Its fundamental ideas may be a challenge to wrap one's head around initially, but I believe that the reward of cleaner, simpler, and more reliable code is well worth it.